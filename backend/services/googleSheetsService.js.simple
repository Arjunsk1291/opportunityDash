const GOOGLE_SHEETS_API_URL = 'https://sheets.googleapis.com/v4/spreadsheets';

// âœ… AUTO-DETECT which row contains headers
function findHeaderRow(rows) {
  if (!rows || rows.length === 0) return null;
  
  // Check first 5 rows for header row
  for (let i = 0; i < Math.min(5, rows.length); i++) {
    const row = rows[i];
    if (!row || row.length === 0) continue;
    
    // Count non-empty cells in this row
    const nonEmptyCells = row.filter(cell => cell && cell.trim()).length;
    
    // Header row should have many non-empty cells (at least 5)
    // and contain text that looks like field names (no numbers)
    if (nonEmptyCells >= 5) {
      console.log(`âœ… Header row detected at index ${i}:`, row.slice(0, 10));
      return i;
    }
  }
  
  return 0; // Default to first row
}

export async function fetchGoogleSheetData(apiKey, spreadsheetId, sheetName) {
  try {
    const url = `${GOOGLE_SHEETS_API_URL}/${spreadsheetId}/values/${sheetName}?key=${apiKey}`;
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Google Sheets API error: ${response.statusText}`);
    }
    
    const data = await response.json();
    const allRows = data.values || [];
    
    if (allRows.length === 0) throw new Error('No data found in sheet');
    
    // âœ… AUTO-DETECT header row
    const headerRowIndex = findHeaderRow(allRows);
    const headers = allRows[headerRowIndex] || [];
    const dataRows = allRows.slice(headerRowIndex + 1);
    
    console.log(`ðŸ“‹ Headers from row ${headerRowIndex}:`, headers);
    console.log(`ðŸ“Š Data rows: ${dataRows.length}`);
    
    return {
      headerRowIndex,
      rows: allRows,
      headers: headers,
      dataRows: dataRows,
    };
  } catch (error) {
    throw new Error(`Failed to fetch Google Sheet: ${error.message}`);
  }
}

// âœ… MAPPING FUNCTION - Maps Google Sheet row to Opportunity object
export function mapSheetRowToOpportunity(row, mapping) {
  // Helper to safely get value from row by column index
  const getValue = (columnIndex) => {
    if (columnIndex === null || columnIndex === undefined || columnIndex === '') return null;
    const idx = parseInt(columnIndex);
    if (isNaN(idx) || idx < 0 || idx >= row.length) return null;
    return row[idx]?.trim() || null;
  };

  const refNo = getValue(mapping.opportunityRefNo);
  const tenderName = getValue(mapping.tenderName);
  const clientName = getValue(mapping.clientName);
  const status = getValue(mapping.opportunityStatus) || getValue(mapping.avenirStatus) || 'Pre-bid';
  const awardStatus = getValue(mapping.awardStatus) || 'PENDING';
  const opportunityValue = parseFloat(getValue(mapping.opportunityValue) || '0') || 0;
  const probability = parseFloat(getValue(mapping.probability) || '20') || 20;
  const expectedValue = opportunityValue * (probability / 100);
  
  // Date parsing
  const dateTenderReceived = getValue(mapping.dateTenderReceived);
  const tenderPlannedSubmissionDate = getValue(mapping.tenderPlannedSubmissionDate);
  const tenderSubmittedDate = getValue(mapping.tenderSubmittedDate);

  return {
    opportunityRefNo: refNo,
    tenderName: tenderName,
    clientName: clientName,
    internalLead: getValue(mapping.internalLead) || 'Unassigned',
    opportunityClassification: getValue(mapping.opportunityClassification) || 'General',
    opportunityStatus: status,
    avenirStatus: getValue(mapping.avenirStatus) || status,
    awardStatus: awardStatus,
    canonicalStage: mapToCanonicalStage(status),
    qualificationStatus: getValue(mapping.qualificationStatus) || 'Under Review',
    groupClassification: getValue(mapping.groupClassification) || 'General',
    domainSubGroup: getValue(mapping.domainSubGroup) || 'General',
    clientType: getValue(mapping.clientType) || 'Unknown',
    
    // VALUES
    opportunityValue: opportunityValue,
    probability: probability,
    expectedValue: expectedValue,
    opportunityValue_imputed: opportunityValue === 0,
    opportunityValue_imputation_reason: opportunityValue === 0 ? 'No value provided - using 0' : '',
    probability_imputed: false,
    probability_imputation_reason: '',
    
    // DATES
    dateTenderReceived: dateTenderReceived,
    tenderPlannedSubmissionDate: tenderPlannedSubmissionDate,
    tenderSubmittedDate: tenderSubmittedDate,
    lastContactDate: getValue(mapping.lastContactDate),
    tenderPlannedSubmissionDate_imputed: false,
    tenderPlannedSubmissionDate_imputation_reason: '',
    lastContactDate_imputed: false,
    lastContactDate_imputation_reason: '',
    
    // TIMELINE
    daysSinceTenderReceived: calculateDaysSince(dateTenderReceived),
    daysToPlannedSubmission: calculateDaysUntil(tenderPlannedSubmissionDate),
    agedDays: calculateDaysSince(dateTenderReceived),
    willMissDeadline: checkWillMissDeadline(dateTenderReceived, tenderPlannedSubmissionDate),
    isAtRisk: checkIsAtRisk(dateTenderReceived, tenderPlannedSubmissionDate),
    
    // OTHER
    partnerInvolvement: getValue(mapping.partnerInvolvement)?.toLowerCase() === 'yes',
    partnerName: getValue(mapping.partnerName) || '',
    country: getValue(mapping.country) || 'UAE',
    remarks: getValue(mapping.remarks) || '',
  };
}

// Map various status formats to canonical stages
function mapToCanonicalStage(status) {
  if (!status) return 'Pre-bid';
  const upper = status.toUpperCase();
  
  const mappings = {
    'PREBID': 'Pre-bid',
    'PRE-BID': 'Pre-bid',
    'RFT': 'Pre-bid',
    'EOI': 'Pre-bid',
    'ONGOING': 'In Progress',
    'IN PROGRESS': 'In Progress',
    'WORKING': 'In Progress',
    'SUBMITTED': 'Submitted',
    'AWARDED': 'Awarded',
    'LOST': 'Lost/Regretted',
    'REGRETTED': 'Lost/Regretted',
    'HOLD': 'On Hold/Paused',
    'PAUSED': 'On Hold/Paused',
    'CLOSED': 'On Hold/Paused',
  };
  
  return mappings[upper] || 'Pre-bid';
}

function calculateDaysSince(dateStr) {
  if (!dateStr) return 0;
  const date = parseDate(dateStr);
  if (!date) return 0;
  const today = new Date();
  return Math.floor((today - date) / (1000 * 60 * 60 * 24));
}

function calculateDaysUntil(dateStr) {
  if (!dateStr) return 999;
  const date = parseDate(dateStr);
  if (!date) return 999;
  const today = new Date();
  return Math.max(0, Math.floor((date - today) / (1000 * 60 * 60 * 24)));
}

function parseDate(dateStr) {
  if (!dateStr) return null;
  
  // Try DD-MMM format: "21-Oct"
  const dmmMatch = dateStr.match(/(\d{1,2})-([A-Za-z]+)/);
  if (dmmMatch) {
    const day = dmmMatch[1];
    const month = dmmMatch[2];
    const year = new Date().getFullYear();
    try {
      return new Date(`${month} ${day}, ${year}`);
    } catch (e) {
      return null;
    }
  }
  
  try {
    return new Date(dateStr);
  } catch (e) {
    return null;
  }
}

function checkWillMissDeadline(receivedDate, submissionDate) {
  if (!submissionDate) return false;
  const daysUntil = calculateDaysUntil(submissionDate);
  return daysUntil < 0;
}

function checkIsAtRisk(receivedDate, submissionDate) {
  if (!submissionDate) return false;
  const daysUntil = calculateDaysUntil(submissionDate);
  return daysUntil >= 0 && daysUntil <= 7;
}
